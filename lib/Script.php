<?php
/**
 * $Id$
 *
 * Copyright (C) 2002-2007 Stephen Grier <stephengrier@users.sourceforge.net>
 *
 * See the inclosed NOTICE file for conditions of use and distribution.
 */

// Client applications.
define("CLIENT_UNKNOWN", "unknown");
define("CLIENT_SMARTSIEVE", "smartsieve");
define("CLIENT_WEBSIEVE", "websieve");

// Test types.
define ("TEST_ADDRESS", "address");
define ("TEST_HEADER", "header");
define ("TEST_SIZE", "size");

// Action types.
define ("ACTION_FILEINTO", "fileinto");
define ("ACTION_REDIRECT", "redirect");
define ("ACTION_REJECT", "reject");
define ("ACTION_KEEP", "keep");
define ("ACTION_DISCARD", "discard");
define ("ACTION_CUSTOM", "custom");
define ("ACTION_VACATION", "vacation");
define ("ACTION_STOP", "stop");

// Bitwise flags.
define ("CONTINUE_BIT", 1);
define ("SIZE_BIT", 2);
define ("ANYOF_BIT", 4);
define ("KEEP_BIT", 8);
define ("STOP_BIT", 16);
define ("REGEX_BIT", 128);


/**
 * Class Script:: implements a sieve script.
 *
 * @author Stephen Grier <stephengrier@users.sourceforge.net>
 * @version $Revision$
 */
class Script {

   /**
    * Name of script.
    * @var string
    * @access public
    */
    var $name = '';

   /**
    * UTF-8 encoded Sieve text.
    * @var string
    * @access public
    */
    var $script;

   /**
    * Script size in bytes.
    * @var integer
    * @access public
    */
    var $size;

   /**
    * Is this a script created by SmartSieve?
    * @var boolean
    * @access public
    */
    var $so = true;

   /**
    * Script mode: basic (GUI) or advanced (direct edit).
    * @var string
    * @access public
    */
    var $mode;

   /**
    * Sieve rules.
    * @var array
    * @access public
    */
    var $rules = array();

   /**
    * Vacation settings.
    * @var array
    * @access public
    */
    var $vacation = array();

   /**
    * Rule priority, current highest.
    * @var integer
    * @access public
    */
    var $pcount;

   /**
    * Client application that wrote this script.
    * @var string
    * @access public
    */
    var $client = CLIENT_UNKNOWN;

   /**
    * Version of client that wrote this script.
    * @var array
    * @access public
    */
    var $version = null;

   /**
    * Error messages.
    * @var string
    * @access public
    */
    var $errstr;

   /**
    * Class constructor.
    *
    * @param string Script name
    * @return void
    */
    function Script($scriptname)
    {
        $this->name = $scriptname;
        $this->script = '';
        $this->size = 0;
        $this->so = true;
        $this->mode = 'basic';
        $this->rules = array();
        $this->vacation = array();
        $this->pcount = 0;
        $this->errstr = '';
    }


    // Class methods.

   /**
    * Get the script content.
    *
    * This will interpret the encoded part of the script if it exists.
    *
    * @return boolean True on success, false on failure
    */
    function getContent()
    {
        global $managesieve;
 
        if (!isset($this->name)){
            $this->errstr = 'getContent: no script name specified';
            return false;
        }
        if (!is_object($managesieve)) {
            $this->errstr = "getContent: no sieve session open";
            return false;
        }
 
        // If script doesn't yet exist, nothing to retrieve. 
        // This will be a SmartSieve script.
        if (!SmartSieve::scriptExists($this->name)) {
            $this->so = true;
            return true;
        }
 
        $resp = $managesieve->getscript($this->name);
        if ($resp === false) {
            $this->errstr = 'getContent: failed getting script: ' . $managesieve->getError();
            return false;
        }

        // Split on newlines.
        $lines = array();
        $lines = preg_split("/\n/", $resp['raw']);
        $rules = array();
        $vacation = array();

        // If this script was created by SmartSieve or Websieve, the first line
        // will have a recognizable format. If not, the script is of an unrecognised
        // format, and the user will be able to edit it in direct edit mode.
        $line = array_shift($lines);
        if (!preg_match("/^# ?Mail(.*)rules for/", $line)) {
            $this->so = false;
            $this->mode = 'advanced';
        } else {
            $this->so = true;
            $line = array_shift($lines);
            if (preg_match("/^#Generated by ([^ ]+) using SmartSieve ([0-9])\.([0-9])\.([0-9])(-([^ ]+))? .+$/", $line, $m)) {
                $this->client = CLIENT_SMARTSIEVE;
                $this->version = array('major'=>$m[2], 'minor'=>$m[3], 'bugfix'=>$m[4],
                                       'tag'=>(isset($m[6])) ? $m[6] : null);
            } elseif (preg_match("/^# Created by Websieve version ([0-9])\.([0-9]{1,2})([a-z])?$/", $line, $m)) {
                $this->client = CLIENT_WEBSIEVE;
                $this->version = array('major'=>$m[1], 'minor'=>$m[2], 'bugfix'=>null,
                                       'tag'=>(isset($m[3])) ? $m[3] : null);
            }
        }
 
        $line = array_shift($lines);
        while (isset($line)) {
            $line = rtrim($line);
            if (substr($line, 0, 18) == '#SmartSieveRule#a:') {
                $serialized = $this->unescapeChars(substr($line, 16));
                $rules[] = unserialize($serialized);
            }
            elseif (substr($line, 0, 18) == '#SmartSieveSpam#a:') {
                $serialized = $this->unescapeChars(substr($line, 16));
                $this->spamRule = unserialize($serialized);
            }
            elseif (substr($line, 0, 22) == '#SmartSieveVacation#a:') {
                $serialized = $this->unescapeChars(substr($line, 20));
                $this->vacation = unserialize($serialized);
            }
            // Legacy metadata format.
            elseif (preg_match("/^ *#rule&&(.*)&&(.*)&&(.*)&&(.*)&&(.*)&&(.*)&&(.*)&&(.*)&&(.*)&&(.*)&&(.*)$/i",
                           $line, $bits)) {
                $rule = array();
                $rule['priority'] = $bits[1];
                $rule['status'] = $bits[2];
                $rule['conditions'] = array();
                $rule['actions'] = array();
                $froms = $this->splitValues($bits[3]);
                if (!empty($froms)) {
                    foreach ($froms as $from) {
                        $condition = array();
                        $condition['type'] = TEST_ADDRESS;
                        $condition['header'] = 'from';
                        $condition['matchStr'] = $from;
                        $rule['conditions'][] = $condition;
                    }
                }
                $tos = $this->splitValues($bits[4]);
                foreach ($tos as $to) {
                    $condition = array();
                    $condition['type'] = TEST_ADDRESS;
                    $condition['header'] = 'to';
                    $condition['matchStr'] = $to;
                    $rule['conditions'][] = $condition;
                }
                $subjects = $this->splitValues($bits[5]);
                foreach ($subjects as $subject) {
                    $condition = array();
                    $condition['type'] = TEST_HEADER;
                    $condition['header'] = 'subject';
                    $condition['matchStr'] = $subject;
                    $rule['conditions'][] = $condition;
                }
                $headers = $this->splitValues($bits[9]);
                $headerMatchStrs = $this->splitValues($bits[10]);
                for ($i=0; $i<count($headers); $i++) {
                    $condition = array();
                    $condition['type'] = TEST_HEADER;
                    $condition['header'] = $headers[$i];
                    $condition['matchStr'] = $headerMatchStrs[$i];
                    $rule['conditions'][] = $condition;
                }
                $size = $this->unescapeChars($bits[11]);
                if (!empty($size)) {
                    $condition = array();
                    $condition['type'] = TEST_SIZE;
                    $condition['kbytes'] = $size;
                    $condition['gthan'] = ($bits[8] & SIZE_BIT);
                    $rule['conditions'][] = $condition;
                }
                $actions = $this->splitValues($bits[6]);
                $actionArgs = $this->splitValues($bits[7]);
                for ($i=0; $i<count($actions); $i++) {
                    $action = array();
                    switch ($actions[$i]) {
                        case ('folder'):
                            $action['type'] = ACTION_FILEINTO;
                            $action['folder'] = $actionArgs[$i];
                            break;
                        case ('address'):
                            $action['type'] = ACTION_REDIRECT;
                            $action['address'] = $actionArgs[$i];
                            break;
                        case ('reject'):
                            $action['type'] = ACTION_REJECT;
                            $action['message'] = $actionArgs[$i];
                            break;
                        case ('discard'):
                            $action['type'] = ACTION_DISCARD;
                            break;
                        case ('custom'):
                            $action['type'] = ACTION_CUSTOM;
                            $action['sieve'] = $actionArgs[$i];
                            break;
                    }
                    $rule['actions'][] = $action;
                }
                if ($bits[8] & KEEP_BIT) {
                    $action = array();
                    $action['type'] = ACTION_KEEP;
                    $rule['actions'][] = $action;
                }
                if ($bits[8] & STOP_BIT) {
                    $action = array();
                    $action['type'] = ACTION_STOP;
                    $rule['actions'][] = $action;
                }

                $rule['flg'] = $bits[8];   // bitwise flag
                $rule['startNewBlock'] = ($bits[8] & CONTINUE_BIT);
                $rule['matchAny'] = ($bits[8] & ANYOF_BIT);
                $rule['useRegex'] = ($bits[8] & REGEX_BIT);
                array_push($rules, $rule);
                if ($rule['priority'] > $this->pcount) {
                    $this->pcount = $rule['priority'];
                }
            }
            elseif (preg_match("/^ *#vacation&&(.*)&&(.*)&&(.*)&&(.*)/i", $line, $bits)) {
                $vacation['days'] = $bits[1];
                $vaddresslist = $this->unescapeChars($bits[2]);
                $vaddresslist = preg_replace("/\"|\s/","", $vaddresslist);
                $vaddresses = array();
                $vaddresses = preg_split("/,/", $vaddresslist);
                $vacation['text'] = $this->unescapeChars($bits[3]);
                $vacation['status'] = $bits[4];
                $vacation['addresses'] = &$vaddresses;
            }
            elseif (preg_match("/^ *#mode&&(.*)/i", $line, $bits)) {
                if ($bits[1] == 'basic') {
                    $this->mode = 'basic';
                } elseif ($bits[1] == 'advanced') {
                    $this->mode = 'advanced';
                } else {
                    $this->mode = 'advanced';
                }
            }
            $line = array_shift($lines);
        }
        $this->script = $resp['raw'];
        $this->size = $resp['size']; 
        $this->rules = $rules;
        $this->vacation = $vacation;
        return true;
    }
 
 
   /**
    * Generate and upload the script.
    *
    * @return boolean true on success, false on failure
    */
    function updateScript()
    {
        global $managesieve;
        $activerules = false;
        $regexused = false;
        $rejectused = false;
        $vacationused = false;
        $notifyused = false;
        $imapflagsused = false;

        include_once SmartSieve::getConf('lib_dir', 'lib') . '/version.php';

        if (!is_object($managesieve)) {
            $this->errstr = "updateScript: no sieve session open";
            return false;
        }

        // Don't overwrite a non-SmartSieve script if configured not to.
        if (!$this->so && SmartSieve::getConf('allow_write_unrecognised_scripts') === false) {
            $this->errstr = 'updateScript: encoding not recognised: not safe to overwrite ' . $this->name;
            return false;
        }

        // Generate the sieve content from rules.

        $newscriptbody = '';
        $continue = 1;
 
        foreach ($this->rules as $rule) {
            $newruletext = '';

            // Generate sieve if rule is enabled.
            if ($rule['status'] == 'ENABLED') {
                $activerules = true;
 
                // Conditions
 
                if ($rule['useRegex']) {
                    $regexused = true;
                }
                $started = 0;
 
                if ($this->hasCondition($rule)) {
                    $newruletext .= sprintf("%sif %s (", ($continue) ? '' : 'els', ($rule['matchAny']) ? 'anyof' : 'allof');
                    foreach ($rule['conditions'] as $condition) {
                        $newruletext .= ($started) ? ', ' : '';
                        if ($condition['type'] == TEST_ADDRESS) {
                            $not = (preg_match("/^\s*!/", $condition['matchStr'])) ? true : false;
                            if ($rule['useRegex']) {
                                $matchType = ':regex';
                            } elseif (preg_match("/\*|\?/", $condition['matchStr']) &&
                                SmartSieve::getConf('websieve_auto_matches') === true) {
                                $matchType = ':matches';
                            } else {
                                $matchType = ':contains';
                            }
                            if ($condition['header'] == 'from') {
                                $newruletext .= sprintf("%saddress %s [\"From\"] \"%s\"", ($not) ? 'not ' : '', $matchType,
                                    ($not) ? preg_replace("/^\s*!/", '', $condition['matchStr']) : $condition['matchStr']);
                            } elseif ($condition['header'] == 'to') {
                                $newruletext .= sprintf("%saddress %s [\"To\",\"Cc\"] \"%s\"", ($not) ? 'not ' : '', $matchType,
                                    ($not) ? preg_replace("/^\s*!/", '', $condition['matchStr']) : $condition['matchStr']);
                            } else {
                                $newruletext .= sprintf("%saddress %s \"%s\" \"%s\"", ($not) ? 'not ' : '', $matchType,
                                    $condition['header'],
                                    ($not) ? preg_replace("/^\s*!/", '', $condition['matchStr']) : $condition['matchStr']);
                            }
                        } elseif ($condition['type'] == TEST_HEADER) {
                           $not = (preg_match("/^\s*!/", $condition['matchStr'])) ? true : false;
                            if ($rule['useRegex']) {
                                $matchType = ':regex';
                            } elseif (preg_match("/\*|\?/", $condition['matchStr']) &&
                                SmartSieve::getConf('websieve_auto_matches') === true) {
                                $matchType = ':matches';
                            } else {
                                $matchType = ':contains';
                            }
                            if ($condition['header'] == 'subject') {
                                $newruletext .= sprintf("%sheader %s \"subject\" \"%s\"", ($not) ? 'not ' : '', $matchType,
                                    ($not) ? preg_replace("/^\s*!/", '', $condition['matchStr']) : $condition['matchStr']);
                            } else {
                                $newruletext .= sprintf("%sheader %s \"%s\" \"%s\"", ($not) ? 'not ' : '', $matchType, $condition['header'],
                                    ($not) ? preg_replace("/^\s*!/", '', $condition['matchStr']) : $condition['matchStr']);
                            }
                        } elseif ($condition['type'] == TEST_SIZE) {
                            $newruletext .= sprintf("size %s %sK",
                                ($condition['gthan']) ? ':over' : ':under', $condition['kbytes']);
                        }
                        $started = 1;
                    }
                    $newruletext .= ") {\n";
                }
 
                // Actions

                $custom = false;
                foreach ($rule['actions'] as $action) {
                    switch ($action['type']) {
                        case (ACTION_FILEINTO):
                            $newruletext .= sprintf("%sfileinto \"%s\";\n",
                                                    $this->hasCondition($rule) ? "\t" : '',
                                                    $action['folder']);
                            break;
                        case (ACTION_REJECT):
                            $newruletext .= sprintf("%sreject text:\n%s\n.\n;\n",
                                                    $this->hasCondition($rule) ? "\t" : '',
                                                    $action['message']);
                            $rejectused = true;
                            break;
                        case (ACTION_REDIRECT):
                            $newruletext .= sprintf("%sredirect \"%s\";\n",
                                                    $this->hasCondition($rule) ? "\t" : '',
                                                    $action['address']);
                            break;
                        case (ACTION_DISCARD):
                            $newruletext .= sprintf("%sdiscard;\n",
                                                    $this->hasCondition($rule) ? "\t" : '');
                            break;
                        case (ACTION_KEEP):
                            $newruletext .= sprintf("%skeep;\n",
                                                    $this->hasCondition($rule) ? "\t" : '');
                            break;
                        case (ACTION_STOP):
                            $newruletext .= sprintf("%sstop;\n",
                                                    $this->hasCondition($rule) ? "\t" : '');
                            break;
                        case (ACTION_CUSTOM):
                            // Scrap the above and just display the custom text.
                            $newruletext = $action['sieve'];
                            $custom = true;
                            if (stripos($action['sieve'], ':regex') !== false) {
                                $regexused = true;
                            } if (stripos($action['sieve'], 'reject') !== false) {
                                $rejectused = true;
                            } if (stripos($action['sieve'], 'vacation') !== false) {
                                $vacationused = true;
                            } if (stripos($action['sieve'], 'notify') !== false) {
                                $notifyused = true;
                            } if (stripos($action['sieve'], 'addflag') !== false ||
                                  stripos($action['sieve'], 'setflag') !== false ||
                                  stripos($action['sieve'], 'removeflag') !== false) {
                                $imapflagsused = true;
                            }
                            continue 2;
                            break;
                    }
                }
 
                if ($this->hasCondition($rule) && $custom == false) {
                    $newruletext .= "}\n";
                }

                // Should next rule start with an "if..."?
                $continue = 0;
                if ($rule['startNewBlock'] || $this->hasCondition($rule) == false) {
                    $continue = 1;
                }

                $newscriptbody .= $newruletext . "\n";
 
            } // end 'if ! ENABLED'
        }
 
        // Vacation rule

        if ($this->vacation) {
            $vacation = $this->vacation;
            if (!$vacation['status']) {
                $this->vacation['status'] = 'on';
            }
            if ($vacation['status'] == 'on') {
                $newscriptbody .= "vacation";
                if ($vacation['days']){
                    $newscriptbody .= " :days " . $vacation['days'];
                }
                if (!empty($vacation['addresses'])) {
                    $newscriptbody .= " :addresses [";
                    for ($i=0; $i<count($vacation['addresses']); $i++) {
                        $newscriptbody .= sprintf("%s\"%s\"", ($i != 0) ? ', ' : '',
                                                  $vacation['addresses'][$i]);
                    }
                    $newscriptbody .= "]";
                }
                $newscriptbody .= " text:\n" . $vacation['text'] . "\n.\n;\n\n";
            }
        }
 
        // Generate script header and add a "require" line if needed.
 
        $newscripthead = "";
        $newscripthead .= "#Mail filter rules for " . $_SESSION['smartsieve']['authz'] . "\n";
        $newscripthead .= '#Generated by ' . $_SESSION['smartsieve']['auth'] . ' using SmartSieve ' . VERSION . ' ' . date(SmartSieve::getConf('script_date_format', 'Y/m/d H:i:s'));
        $newscripthead .= "\n";
 
        $newrequire = '';
        if ($activerules) {
            $newrequire .= "require [\"fileinto\"";
            if ($regexused) {
                $newrequire .= ',"regex"';
            } if ($rejectused) {
                $newrequire .= ',"reject"';
            } if ($this->vacation && $this->vacation['status'] == 'on' || $vacationused) {
                $newrequire .= ',"vacation"';
            } if ($notifyused) {
                $newrequire .= ',"notify"';
            } if ($imapflagsused) {
                $newrequire .= ',"imapflags"';
            }
            $newrequire .= "];\n\n";
        }
        // No active rules, but might still have an active vacation rule.
        elseif ($this->vacation && $this->vacation['status'] == 'on') {
            $newrequire .= "require [\"vacation\"];\n\n";
        }
 
        // Generate an encoded version of script content.
 
        $newscriptfoot = "";
        $pcount = 1;
        $newscriptfoot .= "##PSEUDO script start\n";
        foreach ($this->rules as $rule) {
            // Add rule to foot if status != deleted. This is how we delete a rule.
            if ($rule['status'] != 'DELETED') {
                // Reset priority value. Note, we only do this for 
                // compatibility with Websieve. SmartSieve never uses it.
                $rule['priority'] = $pcount;
                $from = array();
                $to = array();
                $subject = array();
                $headers = array();
                $headerMatchStrs = array();
                $size = '';
                $flg = 0;
                foreach ($rule['conditions'] as $condition) {
                    if ($condition['type'] == TEST_ADDRESS) {
                        if ($condition['header'] == 'from') {
                            $from[] = $condition['matchStr'];
                        } elseif ($condition['header'] == 'to') {
                            $to[] = $condition['matchStr'];
                        }
                    } elseif ($condition['type'] == TEST_HEADER) {
                        if ($condition['header'] == 'subject') {
                            $subject[] = $condition['matchStr'];
                        } else {
                            $headers[] = $condition['header'];
                            $headerMatchStrs[] = $condition['matchStr'];
                        }
                    } elseif ($condition['type'] == TEST_SIZE) {
                        $size = $condition['kbytes'];
                        $flg = $flg | $condition['gthan'];
                    }
                }
                $actions = array();
                $actionArgs = array();
                foreach ($rule['actions'] as $action) {
                    switch ($action['type']) {
                        case (ACTION_FILEINTO):
                            $actions[] = 'folder';
                            $actionArgs[] = $action['folder'];
                            break;
                        case (ACTION_REJECT):
                            $actions[] = 'reject';
                            $actionArgs[] = $action['message'];
                            break;
                        case (ACTION_REDIRECT):
                            $actions[] = 'address';
                            $actionArgs[] = $action['address'];
                            break;
                        case (ACTION_DISCARD):
                            $actions[] = 'discard';
                            $actionArgs[] = 'discard'; // Dummy value.
                            break;
                        case (ACTION_KEEP):
                            $flg = $flg | KEEP_BIT;
                            break;
                        case (ACTION_STOP):
                            $flg = $flg | STOP_BIT;
                            break;
                        case (ACTION_CUSTOM):
                            $actions[] = 'custom';
                            $actionArgs[] = $action['sieve'];
                            break;
                    }
                }
                $flg = $flg | $rule['startNewBlock'] | $rule['matchAny'] | $rule['useRegex'];
#                $newscriptfoot .= sprintf("#rule&&%s&&%s&&%s&&%s&&%s&&%s&&%s&&%s&&%s&&%s&&%s\n",
#                     $rule['priority'], $this->escapeChars($rule['status']), $this->concatenateValues($from),
#                     $this->concatenateValues($to), $this->concatenateValues($subject),
#                     $this->concatenateValues($actions), $this->concatenateValues($actionArgs), $flg, 
#                     $this->concatenateValues($headers), $this->concatenateValues($headerMatchStrs), $size);
                $newscriptfoot .= '#SmartSieveRule#' . $this->escapeChars(serialize($rule)) . "\n";
                $pcount = $pcount+2;
            }
        }
        if ($this->vacation) {
            $vacation = $this->vacation;
            $newscriptfoot .= sprintf("#vacation&&%s&&", $vacation['days']);
            for ($i=0; $i<count($vacation['addresses']); $i++) {
                $newscriptfoot .= sprintf("%s\"%s\"", ($i != 0) ? ', ' : '',
                    $this->escapeChars($vacation['addresses'][$i]));
            }
            $newscriptfoot .= sprintf("&&%s&&%s\n", $this->escapeChars($vacation['text']),
                                      $vacation['status']);
        }
        $newscriptfoot .= sprintf("#mode&&%s\n", $this->mode);
 
        // Put the script content together.
        $newscript = $newscripthead . $newrequire . $newscriptbody . $newscriptfoot;

        // But if we're in direct edit mode, content comes direct from the user.
        if ($this->mode == 'advanced') {
            $newscript = $newscripthead . $this->removeEncoding()  . $newscriptfoot;
        }

        $this->script = $newscript;
 
        // Upload the updated script.
        $slist = SmartSieve::getScriptList();
        $scriptfile = $this->name;
        if (!$managesieve->putScript($scriptfile, $newscript)) {
            $this->errstr = 'updateScript: putscript failed: ' . $managesieve->getError();
            return false;
        }

        // If this script is not the active script on the server, set it as the 
        // active script if 1) configured to activate when saving changes; 2) if 
        // only allowing user to edit this script, or 3) there are no existing 
        // scripts on the server.
        if ($this->name !== SmartSieve::getActiveScript() &&
            (SmartSieve::getConf('update_activate_script') === true ||
             SmartSieve::getConf('allow_multi_scripts') === false ||
             count($slist) === 0)) {
            if (!$managesieve->setActive($this->name)) {
                $this->errstr = 'updateScript: activatescript failed: ' . $managesieve->getError();
                return false;
            }
        }
        // All went well.
        return true;
    }


   /**
    * Return the sieve script content with any encoded lines stripped out.
    *
    * @return string The script content minus encoded lines
    */
    function removeEncoding()
    {
        global $script;
        $raw = '';
        $encs = array('^ *##PSEUDO','^ *#rule','^ *#vacation','^ *#mode',
                      '^ *# ?Mail(.*)rules for','^ *# ?Created by Websieve',
                      '^ *#Generated (.+) SmartSieve');
        $lines = array();
        $lines = explode("\n", $script->script);
        foreach ($lines as $line){
            foreach ($encs as $enc){
                if (preg_match("/$enc/", $line))
                    continue 2;
            }
            $raw .= $line . "\n";
        }
        return $raw;
    }

   /**
    * Make a string safe for the encoded index. Replace CRLFs and & chars.
    *
    * @param string $string The string to make safe
    * @return string The safe string
    */
    function escapeChars($string)
    {
        $string = preg_replace('/\\\\/', '\\\\\\', $string);
        $string = preg_replace("/\r\n/", "\\n", $string);
        $string = preg_replace("/&/", "\&", $string);
        $string = preg_replace("/\|/", "\|", $string);
        return $string;
    }

   /**
    * Unescape a string made safe by escapeChars().
    *
    * @param string $string The string to unescape
    * @return string The unescaped string
    */
    function unescapeChars($string)
    {
        $string = preg_replace("/\\\\n/", "\r\n", $string);
        $string = preg_replace("/\\\&/", "&", $string);
        // 1.0.0-RC2 and newer escape '\' and '|'.
        if ($this->checkVersion(1, 0, 0, 'RC2') >= 0) {
            $string = preg_replace("/\\\\\|/", "|", $string);
            $string = preg_replace('/\\\\\\\\/', '\\', $string);
        }
        return $string;
    }

   /**
    * Concatenate an array of string values together, separated by a pipe char.
    *
    * @param array $values An array of string values to be concatenated together
    * @return string The concatenated values
    */
    function concatenateValues($values)
    {
        $string = '';
        foreach ($values as $value) {
            $value = $this->escapeChars($value);
            $string .= sprintf("%s%s", (strlen($string) != 0) ? '|' : '', $value);
        }
        return $string;
    }

   /**
    * Split a string on pipe characters.
    *
    * @param string $string The string to split
    * @return array The values
    */
    function splitValues($string)
    {
        $values = array();
        // Version 1.0.0-RC2 and newer supports concatenated values.
        if ($this->checkVersion(1, 0, 0, 'RC2') >= 0) {
            $buf = '';
            for ($i=0; $i<strlen($string); $i++) {
                // Split on un-escaped pipe chars.
                if ($string[$i] == '|' &&
                    isset($string[$i-1]) && $string[$i-1] != '\\') {
                    $values[] = $this->unescapeChars($buf);
                    $buf = '';
                } else {
                    $buf .= $string[$i];
                }
            }
            if (!empty($buf)) {
                $values[] = $this->unescapeChars($buf);
            }
        } else {
            if (!empty($string)) {
                $values[] = $this->unescapeChars($string);
            }
        }
        return $values;
    }

   /**
    * Check what version of SmartSieve this script was created by.
    *
    * @param integer $major Major version number
    * @param integer $minor Minor version number
    * @param integer $bugfix Bugfix version number
    * @param string $tag, Version tag
    * @return integer < 0 if version is earlier, 0 if the same, or > 0 if newer
    */
    function checkVersion($major=null, $minor=null, $bugfix=null, $tag=null)
    {
        // If called without parameters use current version.
        if (is_null($major)) {
            include_once SmartSieve::getConf('lib_dir', 'lib') . '/version.php';
            list($major, $minor, $bugfix) = explode('.', VERSION);
            if (strpos($bugfix, '-') !== false) {
                list($bugfix, $tag) = explode('-', $bugfix);
            }
        }
        $scriptVer = sprintf("%s%s%s%s",
                             (isset($this->version['major'])) ? $this->version['major'] : '',
                             (isset($this->version['minor'])) ? $this->version['minor'] : '',
                             (isset($this->version['bugfix'])) ? $this->version['bugfix'] : '',
                             (isset($this->version['tag'])) ? $this->version['tag'] : 'ZZZ');
        $checkVer = sprintf("%s%s%s%s", $major, $minor, $bugfix, (isset($tag)) ? $tag : 'ZZZ');
        return strcmp($scriptVer, $checkVer);
    }

   /**
    * Does rule have a condition.
    *
    * @param array $rule The rule to check
    * @return boolean True if rule has a condition, false if not
    */
    function hasCondition($rule)
    {
        $custom = null;
        // A custom rule might have a condition in it.
        foreach ($rule['actions'] as $action) {
            if ($action['type'] == ACTION_CUSTOM) {
                $custom = $action;
            }
        }
        // If rule has conditions, or is a custom rule with a condition, return true.
        if (!empty($rule['conditions']) ||
            ($custom && preg_match("/^ *(els)?if/i", $custom['sieve']))) {
            return true;
        }
        return false;
    }

}

?>
