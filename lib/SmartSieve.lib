<?php
/*
 * $Id$
 *
 * Copyright 2002-2004 Stephen Grier <stephengrier@users.sourceforge.net>
 *
 * See the inclosed NOTICE file for conditions of use and distribution.
 */


/**
 * Class SmartSieve contains the generic SmartSieve functions 
 * used throughout the application.
 *
 * @author Stephen Grier <stephengrier@users.sourceforge.net>
 * @version $Revision$
 */
class SmartSieve {

   /**
    * Set up the SmartSieve session. This should only be called when 
    * a user logs in.
    *
    * @param auth string authentication user
    * @param passwd string authentication password
    * @param authz string authorization user
    * @param server string server
    * @return mixed boolean true on success, string error if not
    */
    function setSession($auth, $passwd, $authz='', $server)
    {
        global $default, $servers;
        if (empty($auth)) {
            return 'setSession: no auth name supplied';
        }
        if (empty($passwd)) {
            return 'setSession: no password supplied';
        }
        if (empty($server)) {
            return 'setSession: no server supplied';
        }

        $smartsieve = array();

        if (!array_key_exists($server, $servers) ||
            !is_array($servers[$server])) {
            $srvkeys = array_keys($servers);
            $server = (!empty($srvkeys)) ? $srvkeys[0] : '';
        }
        $smartsieve['server'] = SmartSieve::getServerValue($server, 'server');
        $smartsieve['sieveport'] = SmartSieve::getServerValue($server, 'sieveport', '2000');
        $smartsieve['imapport'] = SmartSieve::getServerValue($server, 'imapport', '143');
        $smartsieve['alt_namespace'] = SmartSieve::getServerValue($server, 'alt_namespace', false);
        $smartsieve['namespace_user_prefix'] = SmartSieve::getServerValue($server, 'namespace_user_prefix', '');
        $smartsieve['namespace_shared_prefix'] = SmartSieve::getServerValue($server, 'namespace_shared_prefix', '');
        $smartsieve['maildomain'] = SmartSieve::getServerValue($server, 'maildomain');

        $smartsieve['auth'] = $auth;
        $auth_domain = SmartSieve::getServerValue($server, 'auth_domain');
        if (!empty($auth_domain) && strpos($auth,'@') === false) {
            $smartsieve['auth'] .= '@' . $auth_domain;
        }
        $smartsieve['authz'] = $authz;
        if ($authz == '') {
            $smartsieve['authz'] = $auth;
        }
        if (!empty($auth_domain) && strpos($authz,'@') === false) {
            $smartsieve['authz'] .= '@' . $auth_domain;
        }

        require_once $default->lib_dir . "/Crypt.php";
        $key = Encrypt::generateKey();
        $smartsieve['passwd'] = Encrypt::encrypt($passwd, $key);

        $_SESSION['smartsieve'] = $smartsieve;

        return true;
    }

   /**
    * Login to the managesieve server.
    *
    * @return mixed true on success, string error if not
    */
    function authenticate()
    {
        global $default;
        if (!isset($_SESSION['smartsieve']) || !is_array($_SESSION['smartsieve'])) {
            return 'authenticate: no session started';
        }
        $smartsieve = $_SESSION['smartsieve'];

        require_once $default->lib_dir . "/Crypt.php";

        $key = Encrypt::retrieveKey();
        $passwd = Encrypt::decrypt($smartsieve['passwd'], $key);

        $managesieve = new Managesieve();
        $ret = $managesieve->open($smartsieve['server'], $smartsieve['sieveport']);
        if ($ret !== true) {
            $err = $managesieve->getError();
            $managesieve->close();
            return $err;
        }
        $ret = $managesieve->authenticate($smartsieve['auth'], $passwd, $smartsieve['authz'], SmartSieve::getConf('sasl_mech'));
        if ($ret !== true) {
            $err = $managesieve->getError();
            $managesieve->close();
            return $err;
        }
        $GLOBALS['managesieve'] = $managesieve;
        register_shutdown_function(array('SmartSieve', 'close'));
        return true;
    }

   /**
    * Close the managesieve connection and destroy the managesieve object.
    *
    * @return boolean true
    */
    function close()
    {
        if (isset($GLOBALS['managesieve']) && is_object($GLOBALS['managesieve'])) {
            $GLOBALS['managesieve']->close();
            unset($GLOBALS['managesieve']);
        }
        return true;
    }

    /*
     * return correct mailbox name. apply alternative namespacing if 
     * necessary.
     */
    function getMailboxName($mbox)
    {
        if ($_SESSION['smartsieve']['alt_namespace']){
            if (preg_match("/^INBOX$/i", $mbox)){
                # do nothing.
            }
            elseif (preg_match("/^INBOX\..+/i", $mbox)){
                $mbox = substr($mbox, 6);
            }
            elseif (preg_match("/^user\./i", $mbox)){
                $tmp = substr($mbox, 4);
                $mbox = $_SESSION['smartsieve']['namespace_user_prefix'] . $tmp;
            }
            elseif (preg_match("/^shared\./i", $mbox)){
                $tmp = substr($mbox, 6);
                $mbox = $_SESSION['smartsieve']['namespace_shared_prefix'] . $tmp;
            }
        }
        return $mbox;
    }

   /*
    * This function takes a string $string and returns it, translated 
    * into the language set for this session if possible. When calling 
    * this function the $string argument should always be a raw string 
    * and not a variable, ie. ::text('string') not ::text($string).
    */
    function text($string = '', $args = array())
    {
        global $default;
        static $lang;

        if (!isset($lang)) {
            $lang = SmartSieve::getLang();
        }

        @include "$default->lang_dir/$lang/strings.php";

        if (!empty($phrase[$string])) {
            $string = $phrase[$string];
        }
        return vsprintf($string, $args);
    }

   /*
    * Return the charset to use to display each page. Different 
    * languages might use different charsets.
    */
    function getCharset()
    {
        global $default;
        static $lang;

        if (!isset($lang))
            $lang = SmartSieve::getLang();

        @include "$default->lang_dir/$lang/strings.php";

        if (isset($charset)){
            return $charset;
        }

        return $default->charset;
    }

   /*
    * Return the language to use for this SmartSieve session.
    */
    function getLang()
    {
        global $HTTP_SESSION_VARS;
        global $HTTP_POST_VARS, $HTTP_GET_VARS;
        global $default;

        /* get lang if login form submitted. */
        if (isset($HTTP_POST_VARS['lang']))
            return AppSession::getFormValue('lang');

        /* check if user has changed language on login page. */
        if (isset($HTTP_GET_VARS['login_lang']))
            return AppSession::getFormValue('login_lang');

        /* check if language is set in the session. */
        if (isset($HTTP_SESSION_VARS['smartsieve_lang']))
            return $HTTP_SESSION_VARS['smartsieve_lang'];

        /* if none of the above, use the default. */
        return $default->language;
    }

   /*
    * Convert a modified UTF-7 encoded mailbox name (RFC-2060) into the 
    * charset for the current language.
    */
    function mutf7Decode($string)
    {
        $charset = SmartSieve::getCharset();

        /* if we're using the ISO-8859-1 charset, we can just use imap_utf7_decode(). */
        if (strtolower($charset) == 'iso-8859-1' || strtolower($charset) == 'us-ascii') {
            if (extension_loaded('imap')) {
                return imap_utf7_decode($string);
            }
        }

        /* try mbstring if available. */
        if (extension_loaded('mbstring')) {
            $decoded = @mb_convert_encoding($string, $charset, 'UTF7-IMAP');
            if ($decoded) {
                return $decoded;
            }
        }

        /* try iconv if available. use transliterations to avoid warnings about 
         * incompatible characters. also, add extra ascii char to avoid iconv bug. */
        if (extension_loaded('iconv')) {
            /* convert the modified UTF-7 string to UTF-7. */
            $utf7 = SmartSieve::modifiedToPlainUTF7($string);
            $decoded = @iconv('UTF-7', $charset . '//TRANSLIT', $utf7 . "\0");
            if ($decoded) {
                return $decoded;
            }
        }

        /* if all else fails, use imap_utf7_decode(). If mailbox name includes 
         * non-ISO-8859-1 characters, they will not be decoded correctly. */
        if (extension_loaded('imap')) {
            return imap_utf7_decode($string);
        }

        return $string;
    }

   /*
    * Convert a modified UTF-7 encoded string to unmodified UTF-7.
    * See: RFC-2060.
    */
    function modifiedToPlainUTF7($string)
    {
        $utf7 = '';
        $base64 = false;
        for ($i = 0; $i < strlen($string); $i++) {
            if ($string[$i] == "&") {
                /* Convert the shift char '&' to '+'.
                   Literal '&' will be encoded as '&-'. */
                if ($string[$i+1] == "-") {
                    $utf7 .= "&"; // '&-' -> '&'
                    $i++;
                }
                else {
                    $utf7 .= "+"; // '&' -> '+'
                    $base64 = true;
                }
            }
            elseif ($string[$i] == "-" && $base64) {
                /* shift back to us-ascii. */
                $base64 = false;
            }
            else {
                if ($base64 && $string[$i] == ",") {
                    $utf7 .= "/"; // ',' -> '/'
                }
                elseif (!$base64 && $string[$i] == "+") {
                    $utf7 .= "+-"; // '+' -> '+-'
                }
                else {
                    $utf7 .= $string[$i];
                }
            }
        }
        return $utf7;
    }

   /**
    * Get the value of a config option. Returns the value of the setting 
    * or null if not set, thereby avoiding Undefined variable warnings.
    *
    * @param option string config option to get
    * @param def    string default value
    * @return mixed config value, possibly null
    */
    function getConf($option, $def=null)
    {
        require_once "conf/config.php";
        global $default;
        if (isset($default->$option)) {
            return $default->$option;
        }
        return $def;
    }

   /**
    * Get a value for a server set in servers.php
    *
    * @param skey string servers array index
    * @param val  string server value
    * @param def  string default value
    * @return mixed server value, possibly null
    */
    function getServerValue($skey, $val, $def=null)
    {
        require_once "conf/servers.php";
        global $servers;
        if (isset($servers[$skey]) && isset($servers[$skey][$val])) {
            return $servers[$skey][$val];
        }
        return $def;
    }

   /**
    * Write a message to the log.
    *
    * @param msg string message to write to log
    * @param level integer one of the LOG_* constants
    * @return mixed boolean true on success, string error if not
    */
    function writeToLog($msg, $level=LOG_DEBUG)
    {
        static $log;
        if (SmartSieve::getConf('logging') == false) {
            return true;
        }
        if ($level > SmartSieve::getConf('logging_level')) {
            return true;
        }

        if (!is_object($log)) {
            include_once SmartSieve::getConf('lib_dir') . "/Log.php";

            if (SmartSieve::getConf('logging_method') === null ||
                SmartSieve::getConf('logging_facility') === null ||
                SmartSieve::getConf('logging_ident') === null) {
                return 'writeToLog: logging not configured correctly';
            }
            $log = new Log(SmartSieve::getConf('logging_method'),
                           SmartSieve::getConf('logging_facility'),
                           SmartSieve::getConf('logging_ident'));

            if ($log->errstr){
                return $log->errstr;
            }
            if (!is_object($log)){
                return 'writeToLog: failed to create log object';
            }
        }

        return ($log->writetoLog($msg, $level)) ? true : $log->errstr;
    }

   /**
    * Set an error notice message. If called without the msg parameter 
    * this will return the current set of error messages.
    *
    * @param msg string the error message to set
    * @return mixed boolean true or array of string messages
    */
    function setError($msg=null)
    {
        if (!isset($_SESSION['errors']) || !is_array($_SESSION['errors'])) {
            $_SESSION['errors'] = array();
        }
        if ($msg === null) {
            $errors = $_SESSION['errors'];
            unset($_SESSION['errors']);
            return $errors;
        }
        $_SESSION['errors'][] = $msg;
        return true;
    }

   /**
    * Set a notice message. If called without the msg parameter
    * this will return the current set of notices.
    *
    * @param msg string the message to set
    * @return mixed boolean true or array of string messages
    */
    function setNotice($msg=null)
    {
        if (!isset($_SESSION['notices']) || !is_array($_SESSION['notices'])) {
            $_SESSION['notices'] = array();
        }
        if ($msg === null) {
            $notices = $_SESSION['notices'];
            unset($_SESSION['notices']);
            return $notices;
        }
        $_SESSION['notices'][] = $msg;
        return true;
    }

   /**
    * Get the list of Sieve scripts on the server for the current user.
    *
    * @return mixed array of scripts if success, or string error if not
    */
    function getScriptList()
    {
        if (!isset($GLOBALS['managesieve']) || !is_object($GLOBALS['managesieve'])) {
            $ret = SmartSieve::authenticate();
            if ($ret !== true) {
                return $ret;
            }
        }
        global $managesieve;
        $slist = $managesieve->listScripts();
        if ($slist === false) {
            $resp = $managesieve->getLastResponse();
            if ($resp['state'] === F_BYE) {
                SmartSieve::handleReferral();
                return Smartsieve::getScriptList();
            }
            return $managesieve->getError();
        }
        return $slist;
    }

   /**
    * Get the name of the active script.
    *
    * @return mixed string name of active script, or null if none active
    */
    function getActiveScript()
    {
        $slist = SmartSieve::getScriptList();
        if (!is_array($slist)) {
            return "getActiveScript: $slist";
        }
        return array_search(true, $slist, true);
    }

   /**
    * Check if script exists on the server.
    *
    * @param name string name of script
    * @return boolean true if script exists on server, false if not
    */
    function scriptExists($name)
    {
        $slist = array_keys(SmartSieve::getScriptList());
        return in_array($name, $slist, true);
    }

   /**
    * Handle managesieve referrals.
    *
    * @return boolean true on success, or void redirect if not
    */
    function handleReferral()
    {
        global $managesieve;
        $resp = $managesieve->getLastResponse();
        if ($resp['state'] === F_BYE && $resp['code'] === RC_REFERRAL) {
            $rserver = substr($resp['code_args'], 8);
            $managesieve->close();
            $ret = $managesieve->open($rserver, $_SESSION['smartsieve']['sieveport']);
            if ($ret === true) {
                require_once SmartSieve::getConf('lib_dir') . "/Crypt.php";
                $key = Encrypt::retrieveKey();
                $passwd = Encrypt::decrypt($_SESSION['smartsieve']['passwd'], $key);
                $ret = $managesieve->authenticate($_SESSION['smartsieve']['auth'], $passwd, 
                    $_SESSION['smartsieve']['authz'], SmartSieve::getConf('sasl_mech'));
                if ($ret === true) {
                    SmartSieve::setNotice(SmartSieve::text('Referred to server "%s"', $rserver));
                    $_SESSION['smartsieve']['server'] = $rserver;
                    return true;
                }
            }
            SmartSieve::writeToLog('handleReferral: ' . $managesieve->getError(), LOG_ERR);
            SmartSieve::close();
            header('Location: ' . SmartSieve::setUrl('login.php?reason=failure'),true);
            exit;
        }
        return true;
    }

   /**
    * Set the script to edit. Select a script and set the script object for it. 
    * If allow_multi_scripts if false this will always set the default script. 
    * Otherwise, if passed the script parameter this will set that as the working 
    * script. If not, it will set the currently active script or the first from the 
    * current script list, or the default script name if none exist on the server.
    *
    * @param script string the script to edit
    * @return void
    */
    function setWorkingScript($script=null)
    {
        // If not allowing multiple scripts select the default.
        if (SmartSieve::getConf('allow_multi_scripts') === false) {
            $script = SmartSieve::getConf('scriptfile', 'smartsieve');
        }

        if (empty($script)) {
            $slist = SmartSieve::getScriptList();
            if (is_array($slist)) {
                $active = array_search(true, $slist, true);
                $slist = array_keys($slist);
                // If a script is active, select that.
                if ($active !== null && $active !== false) {
                    $script = $active;
                } elseif (count($slist) > 0) {
                    // Select the first from the list.
                    $script = $slist[0];
                }
            } else {
                SmartSieve::setError(SmartSieve::text('Failed reading script list: %s', $slist));
                SmartSieve::writeToLog("setWorkingScript: failed reading script list: $slist", LOG_ERR);
            }
        }
        // If all else fails, select the default.
        if (empty($script)) {
            $script = SmartSieve::getConf('scriptfile', 'smartsieve');
        }
        $_SESSION['smartsieve']['workingScript'] = $script;

        // Set the script object if not already set.
        if (!isset($_SESSION['scripts'][$script]) || !is_object($_SESSION['scripts'][$script])) {
            $_SESSION['scripts'][$script] = new Script($script);
        }
    }

   /**
    * Get the list of mailboxes for the current user.
    *
    * @return array of mailbox names, or string error on failure
    */
    function getMailboxList()
    {
        require_once SmartSieve::getConf('lib_dir') . "/Crypt.php";

        $connstr = sprintf('{%s:%s}INBOX', $_SESSION['smartsieve']['server'], $_SESSION['smartsieve']['imapport']);
        // get encrypted passwd.
        $key = Encrypt::retrieveKey();
        $passwd = Encrypt::decrypt($_SESSION['smartsieve']['passwd'], $key);
        $conn = imap_open($connstr, $_SESSION['smartsieve']['auth'], $passwd, OP_HALFOPEN);
        if (!$conn){
            return 'getMailboxList: imap_open failed: ' . imap_last_error();
        }

        $mboxlist = array();
        $mboxes = array();
        $connstr = sprintf('{%s:%s}', $_SESSION['smartsieve']['server'], $_SESSION['smartsieve']['imapport']);
        $mboxes = imap_listmailbox($conn,$connstr,"*");

        if (!is_array($mboxes) || count($mboxes) == 0) {
            return 'getMailboxList: imap_listmailbox failed: ' . imap_last_error();
        }

        foreach ($mboxes as $mbox) {
            $mbox = SmartSieve::mutf7Decode($mbox);
            $label = str_replace($connstr, '', $mbox);
            $mboxlist[] = $label;
        }

        imap_close($conn);
        return $mboxlist;
    }

   /**
    * Return a formatted url. Prepend the webroot if requested.
    * Set the session id as a parameter if the browser is not 
    * accepting cookies.
    *
    * @param uri string resourse to format
    * @param prependRoot boolean prepend the webroot
    * @return string formatted url
    */
    function setUrl($uri, $prependRoot=true)
    {
        $url = '';
        if ($prependRoot) {
            $baseurl = SmartSieve::getConf('baseurl', '');
            if (substr($baseurl, -1) != '/') {
                $baseurl .= '/';
            }
            $url = $baseurl . $uri;
        }
        if (!isset($_COOKIE[session_name()])) {
            // Add session_id as url parameter.
            if (strstr($url, '?') === false) {
                $url .= '?';
            } else {
                $url .= '&';
            }
            $url .= urlencode(session_name()) . '=' . session_id();
        }
        return $url;
    }


}

/* end class SmartSieve. */



class AppSession {

  var $auth;          /* authentication user. */
  var $authz;         /* proxy authorization user. */
  var $passwd;        /* authentication user's password. */
  var $lscript;       /* script name passed from login form. */
  var $server;        /* sieve server to connect to. */
  var $sieveport;     /* port on sieve server to connect to. */
  var $imapport;      /* port on imapd to connect to. */
  var $alt_namespace; /* boolean: using alternative namespace? */
  var $namespace_user_prefix;   /* alt_namespace user prefix. */
  var $namespace_shared_prefix; /* alt_namespace shared prefix. */
  var $maildomain;    /* ie $user@$maildomain. */
  var $scriptlist;    /* array: user's scripts on the server. */
  var $mboxlist;      /* array: user's IMAP mailboxes. */
  var $activescript;  /* name of currently active script on server (if any). */
  var $workingscript; /* name of script being edited. */
  var $errstr;        /* error text. */

  // class constructor
  function AppSession () {
    global $default;

    // defaults
    $this->auth = '';
    $this->passwd = '';
    $this->lscript = '';
    $this->server = '127.0.0.1';
    $this->authz = '';
    $this->sieveport = '2000';
    $this->imapport = '143';
    $this->alt_namespace = false;
    $this->namespace_user_prefix = '';
    $this->namespace_shared_prefix = '';
    $this->maildomain = 'localhost';
    $this->scriptlist = array();
    $this->mboxlist = array();
    $this->activescript = '';
    $this->workingscript = '';
    $this->errstr = '';

    return true;
  }


  // class methods


  function initialize () {
	global $sieve, $HTTP_POST_VARS, $servers;

	require_once $GLOBALS['default']->lib_dir . "/Crypt.php";

	// can't to much if user didn't supply these
	// from the login form
	if (!$GLOBALS['HTTP_POST_VARS']['auth']){
            $this->errstr = 'initialize: no username supplied';
            return false;
        }
        if (!$GLOBALS['HTTP_POST_VARS']['passwd']){
            $this->errstr = 'initialize: no password supplied';
	    return false;
	}

	if (isset($GLOBALS['HTTP_POST_VARS']['server']))
	{
	    $server = $servers[$HTTP_POST_VARS['server']];
	    if (!is_array($server)){
                $this->errstr = 'initialize: server ' . $HTTP_POST_VARS['server'] . ' is not an array';
                return false;
            }

	    if (isset($server['server'])) 
                $this->server = $server['server'];
	    if (isset($server['sieveport'])) 
                $this->sieveport = $server['sieveport'];
	    if (isset($server['imapport'])) 
                $this->imapport = $server['imapport'];
	    if (isset($server['alt_namespace'])) 
                $this->alt_namespace = $server['alt_namespace'];
            if (isset($server['namespace_user_prefix'])) 
                $this->namespace_user_prefix = $server['namespace_user_prefix'];
            if (isset($server['namespace_shared_prefix'])) 
                $this->namespace_shared_prefix = $server['namespace_shared_prefix'];
	    if (isset($server['maildomain'])) 
                $this->maildomain = $server['maildomain'];
	}

        $this->auth = $this->getFormValue('auth');
        if (!empty($server['auth_domain']) && strpos($this->auth,'@') === false) {
            $this->auth .= '@' . $server['auth_domain'];
        }
        $this->authz = $this->getFormValue('authz');
        if ($this->authz == '') {
            $this->authz = $this->auth;
        }
        if (!empty($server['auth_domain']) && $this->authz != '' && 
            strpos($this->authz,'@') === false) {
            $this->authz .= '@' . $server['auth_domain'];
        }
        // encrypt the passwd. decrypt when needed.
        $key = Encrypt::generateKey();
        $this->passwd = Encrypt::encrypt($this->getFormValue('passwd'),$key);

        // user supplied overrides
        if (!empty($GLOBALS['HTTP_POST_VARS']['scriptfile'])) {
            $this->lscript = $this->getFormValue('scriptfile');
        }

	$GLOBALS['HTTP_SESSION_VARS']['sieve'] = &$this;
	session_register('sieve');

	return true;
  }


  function authenticate () {

    if (!$this->openSieveSession()) {
	return false;
    }
    if (!$this->closeSieveSession()) {
	return false;
    }

    return true;
  }


  // open a sieve session
  function openSieveSession () {
    global $default, $HTTP_SESSION_VARS;

    require_once $GLOBALS['default']->lib_dir . "/Crypt.php";

    if (!is_object($HTTP_SESSION_VARS['sieve'])){
        $this->errstr = 'openSieveSession: session not yet initialized';
        return false;
    }

    $key = Encrypt::retrieveKey();
    $passwd = Encrypt::decrypt($this->passwd,$key);

    $this->connection = new SieveSession ($this->server,
                                          $this->sieveport,
                                          $this->auth,
                                          $passwd,
                                          $this->authz,
                                          !empty($default->sasl_mech) ? $default->sasl_mech : '',
                                          $default->socket_timeout ? $default->socket_timeout : 5 );
    if (!$this->connection){
        $this->errstr = 'openSieveSession: failed to initialize SieveSession';
        return false;
    }
 
    if (!$this->connection->start()){
        $this->errstr = 'openSieveSession: failed opening sieve session: ' . $this->connection->errstr;
        return false;
    }

    return true;
  }



  // close a sieve session
  function closeSieveSession () {
    global $HTTP_SESSION_VARS;

    if (!isset($this->connection)) {
        $this->errstr = 'closeSieveSession: no sieve session open';
	return false;
    }

    if (!$this->connection->close()){
        $this->errstr = 'closeSieveSession: failed closing sieve session: ' . $this->connection->errstr;
        return false;
    }

    unset($this->connection);
    return true;
  }


  // get the list of sieve scripts for this user.
  function listScripts () {

    if (!is_object($this->connection)) {
        $this->errstr = "listScripts: no sieve session open";
        return false;
    }

    if (!$this->connection->listscripts()) {
        $this->errstr = $this->connection->errstr;
        return false;
    }
    $this->scriptlist = $this->connection->scriptlist;
    $this->activescript = $this->connection->activescript;
    return true;
  }


  // get a list of imap mailboxes for this user
  function retrieveMailboxList () 
  {
    global $default;
    require_once $GLOBALS['default']->lib_dir . "/Crypt.php";

    $connstr = '{' . $this->server . ':' . $this->imapport . '}INBOX';
    // get encrypted passwd.
    $key = Encrypt::retrieveKey();
    $passwd = Encrypt::decrypt($this->passwd, $key);
    $conn = imap_open($connstr, $this->auth, $passwd, OP_HALFOPEN);
    if (!$conn){
	$this->errstr = "retrieveMailboxList: imap_open failed: " . imap_last_error();
	return false;
    }

    $mboxlist = array();
    $mboxes = array();
    $connstr = '{' . $this->server . ':' . $this->imapport . '}';
    $mboxes = imap_listmailbox($conn,$connstr,"*");

    if (!is_array($mboxes) || count($mboxes) <= 0){
	$this->errstr = "retrieveMailboxList: imap_listmailbox failed: " . imap_last_error();
	return false;
    }

    reset($mboxes);
    foreach ($mboxes as $mbox){
        $mbox = SmartSieve::mutf7Decode($mbox);
	$label = str_replace('{' . "$this->server:$this->imapport" . '}', '', $mbox);
	array_push($mboxlist,$label);
    }

    $this->mboxlist = $mboxlist;
    imap_close($conn);

    return true;
  }


   /*
    * decide what script to open first following login.
    * Working script should be, in order of priority:
    *  user supplied value from login if set
    *  the active script on the server if there is one
    *  the first of a list of user's scripts on server if there are any
    *  else, $default->scriptfile.
    *  if !$default->allow_multi_scripts, open $default->scriptfile.
    */
    function initialWorkingScript () {
        global $default;
        // set $this->scriptlist and $this->activescript.
        if (!$this->listScripts())
            return false;

        if (!empty($this->lscript))
            $this->workingscript = $this->lscript;
        elseif ($this->activescript)
            $this->workingscript = $this->activescript;
        elseif (count($this->scriptlist) > 0)
            $this->workingscript = $this->scriptlist[0];
        else
            $this->workingscript = $default->scriptfile;

        if (!$default->allow_multi_scripts) {
            $this->workingscript = $default->scriptfile;
        }

        return true;
    }


   /*
    * Does the script currently exist on the server?
    */
    function scriptExists ($script) {
        $exists = false;

        $slist = SmartSieve::getScriptList();
        if (!is_array($slist)) {
            return false;
        }

        foreach (array_keys($slist) as $s) {
            if ($s == $script)
                $exists = true;
        }
        return $exists;
    }


   /*
    * Is script the active script on the server?
    */
    function isActiveScript ($script) {
        $active = false;

        if ($script == $GLOBALS['HTTP_SESSION_VARS']['sieve']->activescript)
            $active = true;

        return $active;
    }


   /*
    * Update script list in response to a kick.
    */
    function doListScripts () {
        return count(SmartSieve::getScriptList());
    }


   /*
    * Return the number of scripts belonging to the user on ther server.
    */
    function getNumScripts () {
        return count($GLOBALS['HTTP_SESSION_VARS']['sieve']->scriptlist);
    }


   /*
    * Return most recent error message.
    */
    function getError() {
        return $GLOBALS['HTTP_SESSION_VARS']['sieve']->errstr;
    }


  // log a message.
  function writeToLog ($msg,$level = LOG_DEBUG)
  {
    global $default;
    static $log;

    if (!$default->logging) return true;

    if ($level > $default->logging_level) return true;

    if (!$msg){
	$this->errstr = "writeToLog: no message to log";
	return false;
    }

    if (!is_object($log)){

	include_once "$default->lib_dir/Log.php";

	if (!isset($default->logging_method) ||
	    !isset($default->logging_facility) ||
	    !isset($default->logging_ident))
	{
	    $this->errstr = "writeToLog: logging not configured correctly";
	    return false;
	}

	$log = new Log($default->logging_method,
		$default->logging_facility,
		$default->logging_ident);

	if ($log->errstr){
	    $this->errstr = "writeToLog: " . $log->errstr;
	    return false;
	}

	if (!is_object($log)){
	    $this->errstr = "writeToLog: failed to create log object";
	    return false;
	}
    }

    if (!$log->writetoLog($msg,$level)){
	$this->errstr = "writeToLog: failed writing to log: " .
		$log->errstr;
	return false;
    }

    return true;

  }



  /*
   * Return a cleaned form supplied value. Strip out anything which 
   * looks like an HTML tag, and any backslashes if magic_quotes.gpc
   * is on. Strip trailing whitespace.
   */
  function getFormValue ($var)
  {
	if (isset($GLOBALS['HTTP_POST_VARS'][$var]))
            $val = $GLOBALS['HTTP_POST_VARS'][$var];
	elseif (isset($GLOBALS['HTTP_GET_VARS'][$var]))
	    $val = $GLOBALS['HTTP_GET_VARS'][$var];
	else
	    $val = '';

	/* is magic_quotes_gpc set to on in php.ini? */
	static $magicquotes;
	if (!isset($magicquotes))
	    $magicquotes = get_magic_quotes_gpc();

	if (!is_array($val)){

	    if ($magicquotes)
	        $val = stripslashes($val);

	    /* strip anything which looks like HTML. */
	    $val = strip_tags($val);

	    /* remove trailing whitespace. */
	    $val = rtrim($val);

	}

	return $val;
  }


  /*
   * Return a url for this application. Prepend the webroot if requested. 
   * If the client's browser is not accepting cookies we will need to 
   * set the session id as a url parameter.
   */
  function setUrl ($uri, $prepend_root = true) 
  {
      $url = '';
      if ($prepend_root){
        $baseurl = $GLOBALS['default']->baseurl;
        if (!preg_match('/\/$/', $baseurl))
            $baseurl .= '/';
        $url .= $baseurl;
      }
      $url .= $uri;

      if (!isset($GLOBALS['HTTP_COOKIE_VARS'][session_name()])){
          /* we should add session_id as url parameter. */
          /* if already have params add '&param', or '?param' if not. */
          if (strstr($uri, '?') == false)
              $url .= '?';
          else
              $url .= '&';
          $url .= urlencode(session_name()) . '=' . session_id();
      }

      return $url;
  }



}
// end Session class



class Script {

  var $name;         /* filename of script. */
  var $script;       /* full ascii text of script from server. */
  var $size;         /* size of script in bytes. */
  var $so;           /* boolean: is encoding recognised? ie. not created by SmartSieve. */
  var $mode;         /* basic (GUI) or advanced (direct edit) modes. */
  var $rules;        /* array of sieve rules. */
  var $vacation;     /* vacation settings. */
  var $pcount;       /* highest priority value in ruleset. */
  var $errstr;       /* error text. */

  // class constructor
  function Script ($scriptname) {

	$this->name = $scriptname;
	$this->script = '';
        $this->size = 0;
        $this->so = true;
        $this->mode = 'basic';
	$this->rules = array();
	$this->vacation = array();
	$this->pcount = 0;
        $this->errstr = '';

  }
  // end contructor


  // class functions


  // get sieve script rules for this user
  function retrieveRules () {
    global $HTTP_SESSION_VARS;
    global $managesieve;
    $continuebit = 1;
    $sizebit = 2;
    $anyofbit = 4;
    $keepbit = 8;
    $regexbit = 128;
 
    if (!isset($this->name)){
        $this->errstr = 'retrieveRules: no script name specified';
        return false;
    }
    if (!is_object($managesieve)) {
	$this->errstr = "retrieveRules: no sieve session open";
	return false;
    }
 
    // if script doesn't yet exist, nothing to retrieve. 
    // safe to write to this script file.
    if (!AppSession::scriptExists($this->name)) {
        $this->so = true;
        return true;
    }
 
    $resp = $managesieve->getscript($this->name);
 
    if ($resp === false) {
	$this->errstr = 'retrieveRules: failed getting script: ' . $managesieve->getError();
        return false;
    }

    $lines = array();
    $lines = preg_split("/\n/",$resp['raw']); //,PREG_SPLIT_NO_EMPTY);
 
    $rules = array();
    $vacation = array();
    $regexps = array('^ *##PSEUDO','^ *#rule','^ *#vacation','^ *#mode');

    /* first line should be the recognised encoded head. if not, the script 
     * is of an unrecognised format. We will view this in direct edit mode. */
    $line = array_shift($lines);
    if (!preg_match("/^# ?Mail(.*)rules for/", $line)){
        $this->so = false;
        $this->mode = 'advanced';
    }
    else
        $this->so = true;
 
    $line = array_shift($lines);
    while (isset($line)){
        foreach ($regexps as $regexp){
            if (preg_match("/$regexp/i",$line)){
                $line = rtrim($line);
                if (preg_match(
        "/^ *#rule&&(.*)&&(.*)&&(.*)&&(.*)&&(.*)&&(.*)&&(.*)&&(.*)&&(.*)&&(.*)&&(.*)$/i",                                $line,$bits)){
                    $rule = array();
                    $rule['priority'] = $bits[1];
                    $rule['status'] = $bits[2];
                    $rule['from'] = $bits[3];
                    $rule['to'] = $bits[4];
                    $rule['subject'] = $bits[5];
                    $rule['action'] = $bits[6];
                    $rule['action_arg'] = $bits[7];
		    // <crnl>s will be encoded as \\n. undo this.
		    $rule['action_arg'] = preg_replace("/\\\\n/","\r\n",$rule['action_arg']);
                    $rule['flg'] = $bits[8];   // bitwise flag
                    $rule['field'] = $bits[9];
                    $rule['field_val'] = $bits[10];
                    $rule['size'] = $bits[11];
                    $rule['continue'] = ($bits[8] & $continuebit);
                    $rule['gthan'] = ($bits[8] & $sizebit); // use 'greater than'
                    $rule['anyof'] = ($bits[8] & $anyofbit);
                    $rule['keep'] = ($bits[8] & $keepbit);
                    $rule['regexp'] = ($bits[8] & $regexbit);
                    $rule['unconditional'] = 0;
                    if (!$rule['from'] && !$rule['to'] && !$rule['subject'] &&
                        !$rule['field'] && !$rule['size'] && $rule['action'] &&
                        !($rule['action'] == 'custom' && preg_match("/^ *(els)?if/i", $rule['action_arg']))) {
                        $rule['unconditional'] = 1;
                    }
 
                    array_push($rules,$rule);
		    if ($rule['priority'] > $this->pcount)
			$this->pcount = $rule['priority'];
                }
                if (preg_match("/^ *#vacation&&(.*)&&(.*)&&(.*)&&(.*)/i",$line,$bits)){
                    $vacation['days'] = $bits[1];
                    $vaddresslist = $bits[2];
                    $vaddresslist = preg_replace("/\"|\s/","",$vaddresslist);
                    $vaddresses = array();
                    $vaddresses = preg_split("/,/",$vaddresslist);
                    $vacation['text'] = $bits[3];
		    // <crnl>s will be encoded as \\n. undo this.
		    $vacation['text'] = preg_replace("/\\\\n/","\r\n",$vacation['text']);
                    $vacation['status'] = $bits[4];
                    $vacation['addresses'] = &$vaddresses;
                }
                if (preg_match("/^ *#mode&&(.*)/i",$line,$bits)){
                    if ($bits[1] == 'basic')
                        $this->mode = 'basic';
                    elseif ($bits[1] == 'advanced')
                        $this->mode = 'advanced';
                    else
                        $this->mode = 'advanced';
                }
            }
        }
        $line = array_shift($lines);
    }
 
    $this->script = $resp['raw'];
    $this->size = $resp['size']; 
    $this->rules = $rules;
    $this->vacation = $vacation;
 
    return true;
  }
 
 
  // update and save sieve script
  function updateScript () {
    global $HTTP_SESSION_VARS,$default;
    global $managesieve;
 
    $activerules = 0;
    $regexused = 0;
    $rejectused = 0;
    $vacationused = 0;
 
    include "$default->lib_dir/version.php";
 
    if (!is_object($managesieve)) {
	$this->errstr = "updateScript: no sieve session open";
        return false;
    }

    // don't overwrite a file if not created by SmartSieve,
    // unless configured to do so.
    if (!$this->so && !$default->allow_write_unrecognised_scripts) {
        $this->errstr = 'updateScript: encoding not recognised: not safe to overwrite ' . $this->name;
        return false;
    }
 
    // lets generate the main body of the script from our rules
 
    $newscriptbody = "";
    $continue = 1;
 
    foreach ($this->rules as $rule){
      $newruletext = "";
 
      // don't print this rule if disabled.
      if ($rule['status'] != 'ENABLED') {
      }
      else {
 
        $activerules = 1;
 
        // conditions
 
        $anyall = "allof";
        if ($rule['anyof']) $anyall = "anyof";
        if ($rule['regexp']) {
            $regexused = 1;
        }
        $started = 0;
 
        if (!$rule['unconditional']) {
            if (!$continue) $newruletext .= "els";
            $newruletext .= "if " . $anyall . " (";
            if ($rule['from']) {
                if (preg_match("/^\s*!/", $rule['from'])){
                    $newruletext .= 'not ';
                    $rule['from'] = preg_replace("/^\s*!/","",$rule['from']);
                }
                $match = ':contains';
                if (preg_match("/\*|\?/", $rule['from']) && 
                    !empty($default->websieve_auto_matches)){
                    $match = ':matches';
                }
                if ($rule['regexp']) $match = ':regex';
                $newruletext .= "address " . $match . " [\"From\"]";
                $newruletext .= " \"" . $rule['from'] . "\"";
                $started = 1;
            }
            if ($rule['to']) {
                if ($started) $newruletext .= ", ";
                if (preg_match("/^\s*!/", $rule['to'])){
                    $newruletext .= 'not ';
                    $rule['to'] = preg_replace("/^\s*!/","",$rule['to']);
                }
                $match = ':contains';
                if (preg_match("/\*|\?/", $rule['to']) && 
                    !empty($default->websieve_auto_matches)){
                    $match = ':matches';
                }
                if ($rule['regexp']) $match = ':regex';
                $newruletext .= "address " . $match . " [\"To\",\"TO\",\"Cc\",\"CC\"]";
                $newruletext .= " \"" . $rule['to'] . "\"";
                $started = 1;
            }
            if ($rule['subject']) {
                if ($started) $newruletext .= ", ";
                if (preg_match("/^\s*!/", $rule['subject'])){
                    $newruletext .= 'not ';
                    $rule['subject'] = preg_replace("/^\s*!/","",$rule['subject']);
                }
                $match = ':contains';
                if (preg_match("/\*|\?/", $rule['subject']) && 
                    !empty($default->websieve_auto_matches)){
                    $match = ':matches';
                }
                if ($rule['regexp']) $match = ':regex';
                $newruletext .= "header " . $match . " \"subject\"";
                $newruletext .= " \"" . $rule['subject'] . "\"";
                $started = 1;
            }
            if ($rule['field'] && $rule['field_val']) {
                if ($started) $newruletext .= ", ";
                if (preg_match("/^\s*!/", $rule['field_val'])){
                    $newruletext .= 'not ';
                    $rule['field_val'] = preg_replace("/^\s*!/","",$rule['field_val']);
                }
                $match = ':contains';
                if (preg_match("/\*|\?/", $rule['field_val']) && 
                    !empty($default->websieve_auto_matches)){
                    $match = ':matches';
                }
                if ($rule['regexp']) $match = ':regex';
                $newruletext .= "header " . $match . " \"" . $rule['field'] . "\"";
                $newruletext .= " \"" . $rule['field_val'] . "\"";
                $started = 1;
            }
            if ($rule['size']) {
                $xthan = " :under ";
                if ($rule['gthan']) $xthan = " :over ";
                if ($started) $newruletext .= ", ";
                $newruletext .= "size " . $xthan . $rule['size'] . "K";
                $started = 1;
            }
 
        }
 
        // actions
 
        if (!$rule['unconditional']) $newruletext .= ") {\n\t";

        if (preg_match("/folder/i",$rule['action'])) {
            $newruletext .= "fileinto \"" . $rule['action_arg'] . "\";";
        }
        if (preg_match("/reject/i",$rule['action'])) {
            $newruletext .= "reject text: \n" . $rule['action_arg'] . "\n.\n;";
            $rejectused = 1;
        }
        if (preg_match("/address/i",$rule['action'])) {
            $newruletext .= "redirect \"" . $rule['action_arg'] . "\";";
        }
        if (preg_match("/discard/i",$rule['action'])) {
            $newruletext .= "discard;";
        }
        if ($rule['keep']) $newruletext .= "\n\tkeep;";
        if (!$rule['unconditional']) $newruletext .= "\n}";

        if (preg_match("/custom/i",$rule['action'])) {
            $newruletext = $rule['action_arg'];
            if (preg_match("/:regex/i",$rule['action_arg']))
                $regexused = 1;
            if (preg_match("/reject/i",$rule['action_arg']))
                $rejectused = 1;
            if (preg_match("/vacation/i",$rule['action_arg']))
                $vacationused = 1;
        }
 
        $continue = 0;
        if ($rule['continue']) $continue = 1;
        if ($rule['unconditional']) $continue = 1;
 
        $newscriptbody .= $newruletext . "\n\n";
 
      } // end 'if ! ENABLED'
    }
 
    // vacation rule
 
    if ($this->vacation) {
        $vacation = $this->vacation;
	if (!$vacation['status']) $vacation['status'] = 'on';
	if (!$vacation['text']){
            if (empty($default->vacation_text)){
                $this->errstr = 'updateScript: no vacation message specified';
                return false;
            }
            $vacation['text'] = $default->vacation_text;
        }
        if (!$vacation['days']){
            if (!empty($default->require_vacation_days)){
                if (empty($default->vacation_days)){
                    $this->errstr = 'updateScript: no vacation days value specified';
                    return false;
                }
                $vacation['days'] = $default->vacation_days;
            }
        }

	// filter out invalid addresses.
        if (is_array($vacation['addresses'])){
            $ok_vaddrs = array();
            foreach($vacation['addresses'] as $addr){
                $tokens = explode('@',$addr);
                if (count($tokens) == 2 
                    && $tokens[0] != '' 
                    && strpos($tokens[1],'.') !== false){
                    array_push($ok_vaddrs,$addr);
                }
            }
            $vacation['addresses'] = $ok_vaddrs;
        }

	if ((!is_array($vacation['addresses']) || empty($vacation['addresses'][0])) 
            && !empty($default->require_vacation_addresses)) {
            // If $smartsieve->authz is fully-qualified, use that.
            if (strpos($_SESSION['smartsieve']['authz'],'@') !== false) {
                $vacation['addresses'][] = $_SESSION['smartsieve']['authz'];
            } else {
                if (empty($_SESSION['smartsieve']['maildomain'])){
                    $this->errstr = 'updateScript: no valid vacation addresses supplied';
                    return false;
                }
                $defaultaddr = $_SESSION['smartsieve']['authz'] . '@' . $_SESSION['smartsieve']['maildomain'];
                $vacation['addresses'][] = $defaultaddr;
            }
	}

        if ($vacation['status'] == 'on') {
            $newscriptbody .= "vacation";
            if ($vacation['days']){
                $newscriptbody .= " :days " . $vacation['days'];
            }
            if (!empty($vacation['addresses'])){
                $newscriptbody .= " :addresses [";
                $first = 1;
                foreach ($vacation['addresses'] as $vaddress) {
                    if (!$first) $newscriptbody .= ", ";
                    $newscriptbody .= "\"" . $vaddress . "\"";
                    $first = 0;
                }
                $newscriptbody .= "]";
            }
            $newscriptbody .= " text:\n" . $vacation['text'] . "\n.\n;\n\n";
        }
	// update with any changes.
	$this->vacation = $vacation;
    }
 
    // generate the script head
 
    $newscripthead = "";
    $newscripthead .= "#Mail filter rules for " . $_SESSION['smartsieve']['authz'] . "\n";
    $newscripthead .= '#Generated by ' . $_SESSION['smartsieve']['auth'] . ' using SmartSieve ' . VERSION . ' ' . date($default->script_date_format);
    $newscripthead .= "\n";
 
    $newrequire = '';
    if ($activerules) {
        $newrequire .= "require [\"fileinto\"";
        if ($regexused) $newrequire .= ",\"regex\"";
        if ($rejectused) $newrequire .= ",\"reject\"";
        if ($this->vacation && $this->vacation['status'] == 'on' || $vacationused)
            $newrequire .= ",\"vacation\"";
        $newrequire .= "];\n\n";
    }
    else {
	// no active rules, but might still have an active vacation rule
	if ($this->vacation && $this->vacation['status'] == 'on')
	    $newrequire .= "require [\"vacation\"];\n\n";
    }
	
 
    // generate the encoded script foot
 
    $newscriptfoot = "";
    $pcount = 1;
    $newscriptfoot .= "##PSEUDO script start\n";
    foreach ($this->rules as $rule){
      // only add rule to foot if status != deleted. this is how we delete a rule.
      if ($rule['status'] != 'DELETED') {
	// we need to handle \r\n here.
	$rule['action_arg'] = preg_replace("/\r\n/","\\n",$rule['action_arg']);
	/* reset priority value. note: we only do this
	 * for compatibility with Websieve. */
	$rule['priority'] = $pcount;
        $newscriptfoot .= "#rule&&" . $rule['priority'] . "&&" . $rule['status'] . "&&" . $rule['from'] . "&&" . $rule['to'] . "&&" . $rule['subject'] . "&&" . $rule['action'] .
"&&" . $rule['action_arg'] . "&&" . $rule['flg'] . "&&" . $rule['field'] . "&&" . $rule['field_val'] . "&&" . $rule['size'] . "\n";
	$pcount = $pcount+2;
      }
    }
    if ($this->vacation) {
        $vacation = $this->vacation;
        $newscriptfoot .= "#vacation&&" . $vacation['days'] . "&&";
        $first = 1;
        foreach ($vacation['addresses'] as $address) {
            if (!$first) $newscriptfoot .= ", ";
            $newscriptfoot .= "\"" . $address . "\"";
            $first = 0;
        }
	$vacation['text'] = preg_replace("/\r\n/","\\n",$vacation['text']);
        $newscriptfoot .= "&&" . $vacation['text'] . "&&" . $vacation['status'] . "\n";
    }
    $newscriptfoot .= "#mode&&" . $this->mode . "\n";
 
    $newscript = $newscripthead . $newrequire . $newscriptbody . $newscriptfoot;
    if ($this->mode == 'advanced')
        $newscript = $newscripthead . $this->removeEncoding()  . $newscriptfoot;
    $this->script = $newscript;
 
    $scriptfile = $this->name;
    if (!$managesieve->putScript($scriptfile, $newscript)) {
	$this->errstr = 'updateScript: putscript failed: ' . $managesieve->getError();
        return false;
    }

    if ($this->name === SmartSieve::getActiveScript() &&
        (SmartSieve::getConf('update_activate_script') === true ||
         SmartSieve::getConf('allow_multi_scripts') === false ||
         count(SmartSieve::getScriptList()) === 0)) {
	if (!$managesieve->setActive($this->name)) {
	    $this->errstr = 'updateScript: activatescript failed: ' . $managesieve->getError();
	    return false;
	}
    }

    return true;
  }


/* return Sieve script text with the encoded lines stripped out. */
function removeEncoding ()
{
    global $script;
    $raw = '';
    $encs = array('^ *##PSEUDO','^ *#rule','^ *#vacation','^ *#mode',
                  '^ *# ?Mail(.*)rules for','^ *# ?Created by Websieve',
                  '^ *#Generated (.+) SmartSieve');
    $lines = array();
    $lines = explode("\n", $script->script);
    foreach ($lines as $line){
        foreach ($encs as $enc){
            if (preg_match("/$enc/", $line))
                continue 2;
        }
        $raw .= $line . "\n";
    }
    return $raw;
}


}


?>
